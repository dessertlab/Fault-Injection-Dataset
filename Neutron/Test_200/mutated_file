
import random, binascii, threading, os, time

def pycc_corrupt_string(string):
    if string:
        if (random.randint(0, 1) == 0):
            hexstring = binascii.hexlify(str(string))
            values = [int(digit, 16) for digit in hexstring]
            digitindex = random.randint(0, len(values))
            bitindex = random.randint(0, 3)
            values[(digitindex - 1)] ^= (1 << bitindex)
            result = ''.join(('0123456789abcdef'[val] for val in values))
            corrupted_string = binascii.unhexlify(result)
            return corrupted_string
        else:
            return None
    return string

def pycc_corrupt_dict_key(d):
    if d:
        old_key = random.choice(d.keys())
        corrupted_key = pycc_corrupt(old_key)
        d[corrupted_key] = d.pop(old_key)
    return d

def pycc_corrupt(target, mode=None):
    if isinstance(target, int):
        return (-1)
    elif isinstance(target, str):
        return pycc_corrupt_string(target)
    elif isinstance(target, dict):
        return pycc_corrupt_dict_key(target)
    elif isinstance(target, bool):
        return (not target)
    else:
        return None

def pycc_sleep(milliseconds):
    time.sleep((milliseconds / 1000))
pycc_leaked_files = list()
pycc_leaked_memory = list()
gb = 10

def _pycc_hog_fd():
    try:
        i = 0
        files = []
        pycc_leak_file_dir = '/tmp/pycc_file_leak_dir/'
        os.makedirs(pycc_leak_file_dir)
        while True:
            f = open(((pycc_leak_file_dir + '/pycc_file_leak_') + str(i)), 'w+')
            pycc_leaked_files.append(f)
            i = (i + 1)
    except:
        pass

def _pycc_hog_cpu():
    while True:
        for i in range(100):
            (i * i)

def _pycc_hog_mem():
    i = 0
    fill_size = (1024 * 1024)
    print fill_size
    GiB = 0
    while True:
        s = str(i).zfill(fill_size)
        pycc_leaked_memory.append(s)
        i += 1
        if ((i % 1024) == 0):
            GiB += 1
            if (GiB >= gb):
                return

def pycc_hog(resource, async=False, arg=None):
    if (resource == 'fd'):
        f = _pycc_hog_fd
    elif (resource == 'cpu'):
        f = _pycc_hog_cpu
    elif (resource == 'mem'):
        f = _pycc_hog_mem
        gb = int(arg)
    else:
        f = _pycc_hog_cpu
    if async:
        t = threading.Thread(target=f)
        t.start()
    else:
        f()
import copy
import netaddr
from neutron_lib.api.definitions import portbindings
from neutron_lib import constants
from neutron_lib import exceptions as n_exc
from oslo_db import exception as db_exc
from oslo_log import log as logging
from oslo_utils import excutils
from sqlalchemy import and_
from neutron.common import constants as n_const
from neutron.common import ipv6_utils
from neutron.db import api as db_api
from neutron.db import ipam_backend_mixin
from neutron.db import models_v2
from neutron.ipam import driver
from neutron.ipam import exceptions as ipam_exc
from neutron.objects import ports as port_obj
from neutron.objects import subnet as obj_subnet
LOG = logging.getLogger(__name__)

class IpamPluggableBackend(ipam_backend_mixin.IpamBackendMixin, ):

    def _get_failed_ips(self, all_ips, success_ips):
        ips_list = (ip_dict['ip_address'] for ip_dict in success_ips)
        return (ip_dict['ip_address'] for ip_dict in all_ips if (ip_dict['ip_address'] not in ips_list))

    def _safe_rollback(self, func, *args, **kwargs):
        'Calls rollback actions and catch all exceptions.\n\n        All exceptions are catched and logged here to prevent rewriting\n        original exception that triggered rollback action.\n        '
        try:
            func(*args, **kwargs)
        except Exception as e:
            LOG.warning('Revert failed with: %s', e)

    def _ipam_deallocate_ips(self, context, ipam_driver, port, ips, revert_on_fail=True):
        'Deallocate set of ips over IPAM.\n\n        If any single ip deallocation fails, tries to allocate deallocated\n        ip addresses with fixed ip request\n        '
        deallocated = []
        try:
            for ip in ips:
                try:
                    ipam_subnet = ipam_driver.get_subnet(ip['subnet_id'])
                    ipam_subnet.deallocate(ip['ip_address'])
                    deallocated.append(ip)
                except n_exc.SubnetNotFound:
                    LOG.debug('Subnet was not found on ip deallocation: %s', ip)
        except Exception:
            with excutils.save_and_reraise_exception():
                if (not ipam_driver.needs_rollback()):
                    return
                LOG.debug('An exception occurred during IP deallocation.')
                if (revert_on_fail and deallocated):
                    LOG.debug('Reverting deallocation')
                    self._safe_rollback(self._ipam_allocate_ips, context, ipam_driver, port, deallocated, revert_on_fail=False)
                elif ((not revert_on_fail) and ips):
                    addresses = ', '.join(self._get_failed_ips(ips, deallocated))
                    LOG.error('IP deallocation failed on external system for %s', addresses)
        return deallocated

    def _ipam_allocate_ips(self, context, ipam_driver, port, ips, revert_on_fail=True):
        'Allocate set of ips over IPAM.\n\n        If any single ip allocation fails, tries to deallocate all\n        allocated ip addresses.\n        '
        allocated = []
        ips.sort(key=(lambda x: ('ip_address' not in x)))
        try:
            for ip in ips:
                ip_list = ([ip] if isinstance(ip, dict) else ip)
                subnets = [ip_dict['subnet_id'] for ip_dict in ip_list]
                try:
                    factory = ipam_driver.get_address_request_factory()
                    ip_request = factory.get_request(context, port, ip_list[0])
                    ipam_allocator = ipam_driver.get_allocator(subnets)
                    (ip_address, subnet_id) = ipam_allocator.allocate(ip_request)
                except ipam_exc.IpAddressGenerationFailureAllSubnets:
                    raise n_exc.IpAddressGenerationFailure(net_id=port['network_id'])
                allocated.append({'ip_address': ip_address, 'subnet_id': subnet_id})
        except Exception:
            with excutils.save_and_reraise_exception():
                if (not ipam_driver.needs_rollback()):
                    return
                LOG.debug('An exception occurred during IP allocation.')
                if (revert_on_fail and allocated):
                    LOG.debug('Reverting allocation')
                    self._safe_rollback(self._ipam_deallocate_ips, context, ipam_driver, port, allocated, revert_on_fail=False)
                elif ((not revert_on_fail) and ips):
                    addresses = ', '.join(self._get_failed_ips(ips, allocated))
                    LOG.error('IP allocation failed on external system for %s', addresses)
        return allocated

    def _ipam_update_allocation_pools(self, context, ipam_driver, subnet):
        factory = ipam_driver.get_subnet_request_factory()
        subnet_request = factory.get_request(context, subnet, None)
        ipam_driver.update_subnet(subnet_request)

    def delete_subnet(self, context, subnet_id):
        ipam_driver = driver.Pool.get_instance(None, context)
        ipam_driver.remove_subnet(subnet_id)

    def allocate_ips_for_port_and_store(self, context, port, port_id):
        port_copy = {'port': port['port'].copy()}
        port_copy['port']['id'] = port_id
        network_id = port_copy['port']['network_id']
        ips = []
        try:
            ips = self._allocate_ips_for_port(context, port_copy)
            for ip in ips:
                ip_address = ip['ip_address']
                subnet_id = ip['subnet_id']
                IpamPluggableBackend._store_ip_allocation(context, ip_address, network_id, subnet_id, port_id)
            return ips
        except Exception:
            with excutils.save_and_reraise_exception():
                if ips:
                    ipam_driver = driver.Pool.get_instance(None, context)
                    if (not ipam_driver.needs_rollback()):
                        return
                    LOG.debug('An exception occurred during port creation. Reverting IP allocation')
                    self._safe_rollback(self._ipam_deallocate_ips, context, ipam_driver, port_copy['port'], ips, revert_on_fail=False)

    def _allocate_ips_for_port(self, context, port):
        "Allocate IP addresses for the port. IPAM version.\n\n        If port['fixed_ips'] is set to 'ATTR_NOT_SPECIFIED', allocate IP\n        addresses for the port. If port['fixed_ips'] contains an IP address or\n        a subnet_id then allocate an IP address accordingly.\n        "
        p = port['port']
        fixed_configured = (p['fixed_ips'] is not constants.ATTR_NOT_SPECIFIED)
        subnets = self._ipam_get_subnets(context, network_id=p['network_id'], host=p.get(portbindings.HOST_ID), service_type=p.get('device_owner'), fixed_configured=fixed_configured)
        (v4, v6_stateful, v6_stateless) = self._classify_subnets(context, subnets)
        if fixed_configured:
            ips = self._test_fixed_ips_for_port(context, p['network_id'], p['fixed_ips'], p['device_owner'], subnets)
        else:
            ips = []
            version_subnets = [v4, v6_stateful]
            for subnets in version_subnets:
                if subnets:
                    ips.append([{'subnet_id': s['id']} for s in subnets])
        ips.extend(self._get_auto_address_ips(v6_stateless, p))
        ipam_driver = driver.Pool.get_instance(None, context)
        return self._ipam_allocate_ips(context, ipam_driver, p, ips)

    def _get_auto_address_ips(self, v6_stateless_subnets, port, exclude_subnet_ids=None):
        exclude_subnet_ids = (exclude_subnet_ids or [])
        ips = []
        is_router_port = (port['device_owner'] in constants.ROUTER_INTERFACE_OWNERS_SNAT)
        if (not is_router_port):
            for subnet in v6_stateless_subnets:
                if (subnet['id'] not in exclude_subnet_ids):
                    ips.append({'subnet_id': subnet['id'], 'subnet_cidr': subnet['cidr'], 'eui64_address': True, 'mac': port['mac_address']})
        return ips

    def _test_fixed_ips_for_port(self, context, network_id, fixed_ips, device_owner, subnets):
        'Test fixed IPs for port.\n\n        Check that configured subnets are valid prior to allocating any\n        IPs. Include the subnet_id in the result if only an IP address is\n        configured.\n\n        :raises: InvalidInput, IpAddressInUse, InvalidIpForNetwork,\n                 InvalidIpForSubnet\n        '
        fixed_ip_list = []
        for fixed in fixed_ips:
            subnet = self._get_subnet_for_fixed_ip(context, fixed, subnets)
            is_auto_addr_subnet = ipv6_utils.is_auto_address_subnet(subnet)
            if (('ip_address' in fixed) and (subnet['cidr'] != n_const.PROVISIONAL_IPV6_PD_PREFIX)):
                if (is_auto_addr_subnet and (device_owner not in constants.ROUTER_INTERFACE_OWNERS)):
                    raise ipam_exc.AllocationOnAutoAddressSubnet(ip=fixed['ip_address'], subnet_id=subnet['id'])
                fixed_ip_list.append({'subnet_id': subnet['id'], 'ip_address': fixed['ip_address']})
            elif ((device_owner in constants.ROUTER_INTERFACE_OWNERS_SNAT) or (not is_auto_addr_subnet)):
                fixed_ip_list.append({'subnet_id': subnet['id']})
        return fixed_ip_list

    def _update_ips_for_port(self, context, port, host, original_ips, new_ips, mac):
        'Add or remove IPs from the port. IPAM version'
        added = []
        removed = []
        changes = self._get_changed_ips_for_port(context, original_ips, new_ips, port['device_owner'])
        try:
            subnets = self._ipam_get_subnets(context, network_id=port['network_id'], host=host, service_type=port.get('device_owner'))
        except ipam_exc.DeferIpam:
            subnets = []
        to_add = self._test_fixed_ips_for_port(context, port['network_id'], changes.add, port['device_owner'], subnets)
        if (port['device_owner'] not in constants.ROUTER_INTERFACE_OWNERS):
            to_add += self._update_ips_for_pd_subnet(context, subnets, changes.add, mac)
        ipam_driver = driver.Pool.get_instance(None, context)
        if changes.remove:
            removed = self._ipam_deallocate_ips(context, ipam_driver, port, changes.remove)
        v6_stateless = self._classify_subnets(context, subnets)[2]
        handled_subnet_ids = [ip['subnet_id'] for ip in ((to_add + changes.original) + changes.remove)]
        to_add.extend(self._get_auto_address_ips(v6_stateless, port, handled_subnet_ids))
        if to_add:
            added = self._ipam_allocate_ips(context, ipam_driver, port, to_add)
        return self.Changes(add=added, original=changes.original, remove=removed)

    @db_api.context_manager.writer
    def save_allocation_pools(self, context, subnet, allocation_pools):
        for pool in allocation_pools:
            first_ip = str(netaddr.IPAddress(pool.first, pool.version))
            last_ip = str(netaddr.IPAddress(pool.last, pool.version))
            obj_subnet.IPAllocationPool(context, subnet_id=subnet['id'], start=first_ip, end=last_ip).create()

    def update_port_with_ips(self, context, host, db_port, new_port, new_mac):
        changes = self.Changes(add=[], original=[], remove=[])
        auto_assign_subnets = []
        if new_mac:
            original = self._make_port_dict(db_port, process_extensions=False)
            if (original.get('mac_address') != new_mac):
                original_ips = original.get('fixed_ips', [])
                new_ips = new_port.setdefault('fixed_ips', original_ips)
                new_ips_subnets = [new_ip['subnet_id'] for new_ip in new_ips]
                for orig_ip in original_ips:
                    if ipv6_utils.is_eui64_address(orig_ip.get('ip_address')):
                        subnet_to_delete = {}
                        subnet_to_delete['subnet_id'] = orig_ip['subnet_id']
                        subnet_to_delete['delete_subnet'] = True
                        auto_assign_subnets.append(subnet_to_delete)
                        try:
                            i = new_ips_subnets.index(orig_ip['subnet_id'])
                            new_ips[i] = subnet_to_delete
                        except ValueError:
                            new_ips.append(subnet_to_delete)
        if ('fixed_ips' in new_port):
            original = self._make_port_dict(db_port, process_extensions=False)
            changes = self._update_ips_for_port(context, db_port, host, original['fixed_ips'], new_port['fixed_ips'], new_mac)
        try:
            context.session.expire(db_port, ['fixed_ips'])
            network_id = db_port['network_id']
            for ip in changes.remove:
                self._delete_ip_allocation(context, network_id, ip['subnet_id'], ip['ip_address'])
            for ip in changes.add:
                self._store_ip_allocation(context, ip['ip_address'], network_id, ip['subnet_id'], db_port.id)
            self._update_db_port(context, db_port, new_port, network_id, new_mac)
            if auto_assign_subnets:
                port_copy = copy.deepcopy(original)
                port_copy.update(new_port)
                port_copy['fixed_ips'] = auto_assign_subnets
                self.allocate_ips_for_port_and_store(context, {'port': port_copy}, port_copy['id'])
            getattr(db_port, 'fixed_ips')
        except Exception:
            with excutils.save_and_reraise_exception():
                if ('fixed_ips' in new_port):
                    ipam_driver = driver.Pool.get_instance(None, context)
                    if (not ipam_driver.needs_rollback()):
                        return
                    LOG.debug('An exception occurred during port update.')
                    if changes.add:
                        LOG.debug('Reverting IP allocation.')
                        self._safe_rollback(self._ipam_deallocate_ips, context, ipam_driver, db_port, changes.add, revert_on_fail=False)
                    if changes.remove:
                        LOG.debug('Reverting IP deallocation.')
                        self._safe_rollback(self._ipam_allocate_ips, context, ipam_driver, db_port, changes.remove, revert_on_fail=False)
        return changes

    def delete_port(self, context, id):
        port = self._get_port(context, id)
        ipam_driver = driver.Pool.get_instance(None, context)
        super(IpamPluggableBackend, self).delete_port(context, id)
        self._ipam_deallocate_ips(context, ipam_driver, port, port['fixed_ips'])

    def update_db_subnet(self, context, id, s, old_pools):
        subnet_copy = copy.deepcopy(s)
        (subnet, changes) = super(IpamPluggableBackend, self).update_db_subnet(context, id, s, old_pools)
        ipam_driver = driver.Pool.get_instance(None, context)
        if ('allocation_pools' not in subnet_copy):
            subnet_copy['allocation_pools'] = old_pools
        self._ipam_update_allocation_pools(context, ipam_driver, subnet_copy)
        return (subnet, changes)

    def add_auto_addrs_on_network_ports(self, context, subnet, ipam_subnet):
        'For an auto-address subnet, add addrs for ports on the net.'
        with context.session.begin(subtransactions=True):
            network_id = subnet['network_id']
            port_qry = context.session.query(models_v2.Port)
            ports = port_qry.filter(and_((models_v2.Port.network_id == network_id), (~ models_v2.Port.device_owner.in_(constants.ROUTER_INTERFACE_OWNERS_SNAT))))
            updated_ports = []
            ipam_driver = driver.Pool.get_instance(None, context)
            factory = ipam_driver.get_address_request_factory()
            for port in ports:
                ip = {'subnet_id': subnet['id'], 'subnet_cidr': subnet['cidr'], 'eui64_address': True, 'mac': port['mac_address']}
                ip_request = factory.get_request(context, port, ip)
                try:
                    ip_address = ipam_subnet.allocate(ip_request)
                    allocated = port_obj.IPAllocation(context, network_id=network_id, port_id=port['id'], ip_address=ip_address, subnet_id=subnet['id'])
                    allocated.create()
                    updated_ports.append(port['id'])
                except db_exc.DBReferenceError:
                    LOG.debug('Port %s was deleted while updating it with an IPv6 auto-address. Ignoring.', port['id'])
                    LOG.debug('Reverting IP allocation for %s', ip_address)
                    try:
                        ipam_subnet.deallocate(ip_address)
                    except Exception:
                        LOG.debug('Reverting IP allocation failed for %s', ip_address)
                except ipam_exc.IpAddressAlreadyAllocated:
                    LOG.debug('Port %s got IPv6 auto-address in a concurrent create or update port request. Ignoring.', port['id'])
            return pycc_corrupt(updated_ports)

    def allocate_subnet(self, context, network, subnet, subnetpool_id):
        subnetpool = None
        if (subnetpool_id and (not (subnetpool_id == constants.IPV6_PD_POOL_ID))):
            subnetpool = self._get_subnetpool(context, id=subnetpool_id)
            self._validate_ip_version_with_subnetpool(subnet, subnetpool)
        if (subnet['cidr'] is not constants.ATTR_NOT_SPECIFIED):
            subnet['gateway_ip'] = self._gateway_ip_str(subnet, subnet['cidr'])
            subnet['allocation_pools'] = self._prepare_allocation_pools(subnet['allocation_pools'], subnet['cidr'], subnet['gateway_ip'])
        ipam_driver = driver.Pool.get_instance(subnetpool, context)
        subnet_factory = ipam_driver.get_subnet_request_factory()
        subnet_request = subnet_factory.get_request(context, subnet, subnetpool)
        ipam_subnet = ipam_driver.allocate_subnet(subnet_request)
        subnet_request = ipam_subnet.get_details()
        try:
            subnet = self._save_subnet(context, network, self._make_subnet_args(subnet_request, subnet, subnetpool_id), subnet['dns_nameservers'], subnet['host_routes'], subnet_request)
        except Exception:
            with excutils.save_and_reraise_exception():
                if (not ipam_driver.needs_rollback()):
                    return
                LOG.debug('An exception occurred during subnet creation. Reverting subnet allocation.')
                self._safe_rollback(self.delete_subnet, context, subnet_request.subnet_id)
        return (subnet, ipam_subnet)
